<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>species_distribution_modeling.processing &mdash; Species Distribution Modeling 01/09/2023 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c5a0e6c8"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Species Distribution Modeling
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../main_module.html">main_module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../collection.html">collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../explorer.html">explorer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../processing.html">processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modeling.html">modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">utils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Species Distribution Modeling</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">species_distribution_modeling.processing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for species_distribution_modeling.processing</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">MinMaxScaler</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">pykrige.ok</span> <span class="kn">import</span> <span class="n">OrdinaryKriging</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>   
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>
<span class="kn">import</span> <span class="nn">xgboost</span> <span class="k">as</span> <span class="nn">xgb</span>
<span class="kn">from</span> <span class="nn">skmultilearn.model_selection</span> <span class="kn">import</span> <span class="n">iterative_train_test_split</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">nullcontext</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">mapping</span>
<span class="kn">import</span> <span class="nn">rioxarray</span> <span class="k">as</span> <span class="nn">rxr</span>

<div class="viewcode-block" id="Process"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process">[docs]</a><span class="k">class</span> <span class="nc">Process</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles data preprocessing for species distribution modeling using deep learning.</span>
<span class="sd">    </span>
<span class="sd">    The class includes various preprocessing methods, many of which have been combined into a core preprocessing pipeline.</span>

<span class="sd">    The functions can also be used individually to perform bespoke processing. </span>

<span class="sd">    Attributes:</span>
<span class="sd">        X_data_folder (str): Path to the folder containing explanatory variable data.</span>
<span class="sd">        y_data_folder (str): Path to the folder containing species observation data.</span>
<span class="sd">        processing_folder (str): Path to the folder used for storing processed data.</span>
<span class="sd">        model_in_folder (str): Path to the folder used for storing model input data.</span>
<span class="sd">        model_out_folder (str): Path to the folder used for storing model output data.</span>
<span class="sd">        utils (utils): An instance of the utility class for common functionalities.</span>
<span class="sd">        loaded_model (bool): Flag to indicate if a model is loaded or not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
 
<div class="viewcode-block" id="Process.__init__"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_data_folder</span><span class="p">,</span> <span class="n">y_data_folder</span><span class="p">,</span> <span class="n">processing_folder</span><span class="p">,</span> <span class="n">model_in_folder</span><span class="p">,</span> <span class="n">model_out_folder</span><span class="p">,</span> <span class="n">utils</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the Process class with folder paths and utility class instance.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X_data_folder (str): Path to the folder containing explanatory variable data.</span>
<span class="sd">            y_data_folder (str): Path to the folder containing species observation data.</span>
<span class="sd">            processing_folder (str): Path to the folder used for storing processed data.</span>
<span class="sd">            model_in_folder (str): Path to the folder used for storing model input data.</span>
<span class="sd">            model_out_folder (str): Path to the folder used for storing model output data.</span>
<span class="sd">            utils (utils): An instance of the utility class for common functionalities.</span>
<span class="sd">            **kwargs (dict, optional): Additional keyword arguments, if any.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_data_folder</span> <span class="o">=</span> <span class="n">X_data_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_data_folder</span> <span class="o">=</span> <span class="n">y_data_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span> <span class="o">=</span> <span class="n">processing_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_in_folder</span> <span class="o">=</span> <span class="n">model_in_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_out_folder</span> <span class="o">=</span> <span class="n">model_out_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">=</span><span class="n">utils</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded_model</span> <span class="o">=</span> <span class="kc">False</span>   

        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">ensure_path_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_data_folder</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">ensure_path_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_data_folder</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">ensure_path_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">ensure_path_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_in_folder</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">ensure_path_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_out_folder</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Process.rename_columns"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.rename_columns">[docs]</a>    <span class="k">def</span> <span class="nf">rename_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">rename_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rename columns of a DataFrame.</span>

<span class="sd">        Args:</span>
<span class="sd">            DataFrame (pandas.DataFrame): The input DataFrame with columns to be renamed.</span>
<span class="sd">            rename_dict (dict): A dictionary with current column names as keys and desired column names as values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: The DataFrame with renamed columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_DataFrame</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">rename_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_DataFrame</span></div>
    
<div class="viewcode-block" id="Process.plot_missing_data"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.plot_missing_data">[docs]</a>    <span class="k">def</span> <span class="nf">plot_missing_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot percentage of missing values for each column in a DataFrame.</span>

<span class="sd">        The function calculates the percentage of missing values for each column and plots them </span>
<span class="sd">        in descending order. Columns with higher percentages of missing values are shown in darker shades.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pandas.DataFrame): The DataFrame to analyze for missing values.</span>
<span class="sd">            figsize (tuple, optional): Size of the resulting plot. Defaults to (10, 6).</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: This function only displays a plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
               
        <span class="c1"># Count the number of missing values in each column</span>
        <span class="n">missing_counts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># If there&#39;s no missing data, exit early</span>
        <span class="k">if</span> <span class="n">missing_counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s2">&quot;No missing data to plot.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert the missing counts to percentages</span>
            <span class="n">missing_percentages</span> <span class="o">=</span> <span class="p">(</span><span class="n">missing_counts</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span>

            <span class="c1"># Sort the missing percentages in descending order</span>
            <span class="n">missing_percentages</span> <span class="o">=</span> <span class="n">missing_percentages</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Create a colormap and get colors based on missing percentages</span>
            <span class="n">colormap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s1">&#39;Reds&#39;</span><span class="p">]</span>  <span class="c1"># &#39;Reds&#39; colormap will give darker colors for higher values</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colormap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_percentages</span><span class="p">)))</span>
            
            <span class="c1"># Create a bar plot of the missing value percentages</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
            <span class="n">missing_percentages</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Missing values per feature (%)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Percentage of missing values&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>  <span class="c1"># Adjust the layout to make sure everything fits</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="Process.fill_na_kriging"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.fill_na_kriging">[docs]</a>    <span class="k">def</span> <span class="nf">fill_na_kriging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">lon_column</span><span class="o">=</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">lat_column</span><span class="o">=</span><span class="s1">&#39;lat&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill NaN values in a DataFrame using Ordinary Kriging.</span>

<span class="sd">        This method performs spatial interpolation on NaN values in the </span>
<span class="sd">        provided DataFrame using the Ordinary Kriging technique.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframe (pandas.DataFrame): The input DataFrame with NaN values to interpolate.</span>
<span class="sd">            lon_column (str): Name of the column in the DataFrame containing longitudinal coordinates.</span>
<span class="sd">            lat_column (str): Name of the column in the DataFrame containing latitudinal coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: DataFrame with NaN values interpolated using Ordinary Kriging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lon_column</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lon_column</span><span class="p">)</span>
            <span class="n">lat_column</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lat_column</span><span class="p">)</span>

            <span class="c1"># Extract the spatial coordinates</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">lon_column</span><span class="p">,</span> <span class="n">lat_column</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>

            <span class="c1"># Iterate over each column in the DataFrame</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>

                <span class="c1"># Extract the values with NaN directly</span>
                <span class="n">values_with_nan</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

                <span class="c1"># Find the indices of NaN values</span>
                <span class="n">nan_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values_with_nan</span><span class="p">)</span>

                <span class="c1"># Create an instance of OrdinaryKriging</span>
                <span class="n">kriging</span> <span class="o">=</span> <span class="n">OrdinaryKriging</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="o">~</span><span class="n">nan_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                        <span class="n">coordinates</span><span class="p">[</span><span class="o">~</span><span class="n">nan_indices</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                        <span class="n">values_with_nan</span><span class="p">[</span><span class="o">~</span><span class="n">nan_indices</span><span class="p">])</span>

                <span class="c1"># Interpolate the NaN values</span>
                <span class="n">interpolated_values</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">kriging</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;points&#39;</span><span class="p">,</span>
                                                        <span class="n">coordinates</span><span class="p">[</span><span class="n">nan_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                        <span class="n">coordinates</span><span class="p">[</span><span class="n">nan_indices</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># Assign the interpolated values to the DataFrame</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nan_indices</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolated_values</span>
                    
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Interpolation succeeded on column: </span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="c1"># Periodically clear the memory</span>
                <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
            <span class="c1"># If an error occurred, print it and return the original group</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to process group: </span><span class="si">{</span><span class="n">ve</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span>
        <span class="k">return</span> <span class="n">df</span></div>
    
<div class="viewcode-block" id="Process.fill_na_with_knn"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.fill_na_with_knn">[docs]</a>    <span class="k">def</span> <span class="nf">fill_na_with_knn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">lon_col</span><span class="o">=</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">lat_col</span><span class="o">=</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills missing values in a DataFrame using K-Nearest Neighbors Regression.</span>

<span class="sd">        This function fills missing values in a DataFrame using K-Nearest Neighbors Regression, which</span>
<span class="sd">        considers the longitude and latitude columns to predict the missing values for other columns.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pandas.DataFrame): The input DataFrame with missing values.</span>
<span class="sd">            lon_col (str, optional): The name of the column representing longitude. Defaults to &#39;lon&#39;.</span>
<span class="sd">            lat_col (str, optional): The name of the column representing latitude. Defaults to &#39;lat&#39;.</span>
<span class="sd">            n_neighbors (int, optional): The number of neighbors to use for the K-Nearest Neighbors Regression.</span>
<span class="sd">                Defaults to 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: The DataFrame with missing values filled.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">            ...     &#39;lon&#39;: [1, 2, 3, np.nan],</span>
<span class="sd">            ...     &#39;lat&#39;: [4, 5, 6, np.nan],</span>
<span class="sd">            ...     &#39;value&#39;: [7, 8, 9, np.nan]</span>
<span class="sd">            ... })</span>
<span class="sd">            &gt;&gt;&gt; filled_df = fill_na_with_knn(df)</span>
<span class="sd">            &gt;&gt;&gt; print(filled_df)</span>
<span class="sd">            lon  lat  value</span>
<span class="sd">            0  1.0  4.0    7.0</span>
<span class="sd">            1  2.0  5.0    8.0</span>
<span class="sd">            2  3.0  6.0    9.0</span>
<span class="sd">            3  2.0  5.0    8.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c1"># Create a copy of the original dataframe to avoid modifying it in-place</span>
        <span class="n">filled_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Identify columns with missing values</span>
        <span class="n">columns_with_missing</span> <span class="o">=</span> <span class="n">filled_df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">filled_df</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">()]</span>

        <span class="c1"># Create a DataFrame without missing values for training</span>
        <span class="n">training_df</span> <span class="o">=</span> <span class="n">filled_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

        <span class="c1"># Train a KNeighborsRegressor for each column with missing values</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns_with_missing</span><span class="p">:</span>
            <span class="c1"># Initialize KNeighborsRegressor with 3 neighbors</span>
            <span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">)</span>

            <span class="c1"># Train the model using the non-missing values</span>
            <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">training_df</span><span class="p">[[</span><span class="n">lon_col</span><span class="p">,</span> <span class="n">lat_col</span><span class="p">]],</span> <span class="n">training_df</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>

            <span class="c1"># Predict missing values in the original DataFrame</span>
            <span class="n">missing_rows</span> <span class="o">=</span> <span class="n">filled_df</span><span class="p">[</span><span class="n">filled_df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>
            <span class="n">filled_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">missing_rows</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">missing_rows</span><span class="p">[[</span><span class="n">lon_col</span><span class="p">,</span> <span class="n">lat_col</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">filled_df</span></div>

        
<div class="viewcode-block" id="Process.check_missing_values"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.check_missing_values">[docs]</a>    <span class="k">def</span> <span class="nf">check_missing_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check and report on missing values in the provided DataFrame.</span>

<span class="sd">        Args:</span>
<span class="sd">            DataFrame (pandas.DataFrame): The input DataFrame to check for missing values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: This method only prints information about missing values and doesn&#39;t return anything.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_missing</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># First sum gives per-column count; second sum aggregates across columns</span>
        <span class="k">if</span> <span class="n">total_missing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: There are a total of </span><span class="si">{</span><span class="n">total_missing</span><span class="si">}</span><span class="s2"> missing values in the DataFrame!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s2">&quot;The DataFrame has no missing values.&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Process.preprocess_X_data"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.preprocess_X_data">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess_X_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X_data_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">processing_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lon_column</span><span class="o">=</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">lat_column</span><span class="o">=</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">from_crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">to_crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rename_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;NAME&#39;</span><span class="p">:</span> <span class="s1">&#39;site&#39;</span><span class="p">},</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocesses the explanatory variables data for species distribution modeling.</span>
<span class="sd">        </span>
<span class="sd">        The method performs several preprocessing steps including reading data, filtering columns, dropping duplicates,</span>
<span class="sd">        handling missing values through kriging, converting coordinate systems, normalizing the data, and one-hot encoding categorical variables.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X_data_folder (str, optional): The path to the folder containing the explanatory variable data. Defaults to `self.X_data_folder`.</span>
<span class="sd">            processing_folder (str, optional): The path to the folder used for storing processed data. Defaults to `self.processing_folder`.</span>
<span class="sd">            lon_column (str, optional): Column name for longitude. Defaults to &#39;lon&#39;.</span>
<span class="sd">            lat_column (str, optional): Column name for latitude. Defaults to &#39;lat&#39;.</span>
<span class="sd">            from_crs (str, optional): Coordinate Reference System of the original data. Defaults to &quot;EPSG:4326&quot;.</span>
<span class="sd">            to_crs (str, optional): Coordinate Reference System to convert the data into. Defaults to None.</span>
<span class="sd">            rename_dict (dict, optional): Dictionary to rename specific columns. Defaults to {&#39;NAME&#39;: &#39;site&#39;}.</span>
<span class="sd">            columns (list, optional): List of columns to read from the CSV file. Defaults to None.</span>
<span class="sd">            verbose (bool, optional): If True, outputs intermediate status messages. Defaults to True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            DataFrame: Returns the processed data as a DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">X_data_folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">X_data_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_data_folder</span>
        <span class="k">if</span> <span class="n">processing_folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">processing_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span>

        <span class="c1"># Suppress all outputs if verbose is False</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">suppress_output</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span> <span class="k">else</span> <span class="n">nullcontext</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">read_X_data</span><span class="p">(</span><span class="n">X_data_folder</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Reading data, filtering to columns:</span><span class="se">\n</span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># Sort columns to ensure they are in the same position in the df as in the geographic data (used for creating species distribution maps). </span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span>
        
            <span class="c1"># Drop duplicate geometry</span>
            <span class="n">original_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">lon_column</span><span class="p">,</span> <span class="n">lat_column</span><span class="p">])</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">original_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dropped </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> duplicate geometries&#39;</span><span class="p">)</span>

            <span class="c1"># Rename &quot;Name&quot; column</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Renaming columns: </span><span class="si">{</span><span class="n">rename_dict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">rename_dict</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1">#Filling missing data</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Missing values: &quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_missing_data</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Interpolating and filling missing data using kriging.&quot;</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_na_kriging</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">lon_column</span><span class="p">,</span> <span class="n">lat_column</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Interpolation Complete.</span><span class="se">\n\n</span><span class="s2">Checking for any remaining missing values.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_missing_values</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            
            <span class="c1"># Store the geometry </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geom</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">lon_column</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="n">lat_column</span><span class="p">])</span>
            <span class="c1">#self.geom = df[[lon_column, lat_column]].apply(tuple, axis=1).apply(Point)</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">from_crs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geom_x</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geom_y</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span>

            <span class="c1"># Convert CRS</span>
            <span class="k">if</span> <span class="n">to_crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Converting CRS from: </span><span class="si">{</span><span class="n">from_crs</span><span class="si">}</span><span class="s1"> to: </span><span class="si">{</span><span class="n">to_crs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">to_crs</span><span class="p">)</span>
                <span class="n">df</span><span class="p">[</span><span class="n">lon_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
                <span class="n">df</span><span class="p">[</span><span class="n">lat_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geom_x</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geom_y</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span>

            <span class="c1"># MinMaxScale latitude and longitude</span>
            <span class="n">coord_scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">MinMaxScaling the latitude and longitude columns.&#39;</span><span class="p">)</span>
            <span class="n">coord_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">lon_column</span><span class="p">,</span> <span class="n">lat_column</span><span class="p">]]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column, Datatype for coordinate scaler: </span><span class="si">{</span><span class="p">[(</span><span class="n">column</span><span class="p">,</span><span class="w"> </span><span class="n">datatype</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">column</span><span class="p">,</span><span class="w"> </span><span class="n">datatype</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">zip</span><span class="p">(</span><span class="n">coord_data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span><span class="w"> </span><span class="n">coord_data</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">tolist</span><span class="p">())]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">coord_data</span> <span class="o">=</span> <span class="n">coord_scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">coord_data</span><span class="p">)</span>
        
            <span class="c1"># Save the scaler for future use</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span><span class="p">,</span> <span class="s1">&#39;coord_scaler.pkl&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>   <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">coord_scaler</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="c1">#Save the coordinate scaler for future use</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coordinate scaler saved to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span><span class="si">}</span><span class="s2"> for future use.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Store the scaled geometry </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled_geom</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">lon_column</span><span class="p">,</span> <span class="n">lat_column</span><span class="p">]]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span>
            <span class="c1"># df is already a gdf so we can edit the geometry directly.</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled_geom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled_x</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled_y</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span>

            <span class="c1"># Filter out non-numeric columns</span>
            <span class="n">numeric_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Get variable columns excluding the specified ones</span>
            <span class="n">variable_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">numeric_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;site&#39;</span><span class="p">,</span> <span class="n">lon_column</span><span class="p">,</span> <span class="n">lat_column</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

            <span class="c1"># Sort the values to align them with future data they will be used to transform</span>
            <span class="n">sorted_variable_cols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">variable_cols</span><span class="p">)</span>
                  
            <span class="c1"># StandardScale the numeric variable columns</span>
            <span class="n">variable_scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
            <span class="n">df</span><span class="p">[</span><span class="n">sorted_variable_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable_scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">sorted_variable_cols</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Standard scaling the numeric variable columns: </span><span class="se">\n</span><span class="s1"> </span><span class="si">{</span><span class="n">variable_cols</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column, Datatype for variable scaler: </span><span class="si">{</span><span class="p">[(</span><span class="n">column</span><span class="p">,</span><span class="w"> </span><span class="n">datatype</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">column</span><span class="p">,</span><span class="w"> </span><span class="n">datatype</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">zip</span><span class="p">(</span><span class="n">sorted_variable_cols</span><span class="p">,</span><span class="w"> </span><span class="n">df</span><span class="p">[</span><span class="n">sorted_variable_cols</span><span class="p">]</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">tolist</span><span class="p">())]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">These must match exactly the name and order of columns used for creating the species distribution maps as the scalers are re-used.&#39;</span><span class="p">)</span>
            
            <span class="c1">#Save the variable scaler for future use</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving the numeric variable scaler to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span><span class="si">}</span><span class="s2"> for future use.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span><span class="p">,</span> <span class="s1">&#39;numeric_variable_scaler.pkl&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">variable_scaler</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

            <span class="c1"># Get categorical columns (non-numeric)</span>
            <span class="n">categorical_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            
            <span class="c1"># Exclude any specific columns from being one-hot encoded</span>
            <span class="n">categorical_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">categorical_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;site&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">categorical_cols: </span><span class="si">{</span><span class="n">categorical_cols</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">categorical_cols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># One-hot encode the categorical variables</span>
                <span class="n">one_hot_encoded</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">categorical_cols</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;one_hot_encoded: </span><span class="si">{</span><span class="n">one_hot_encoded</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;One-Hot encoding categorical columns: </span><span class="se">\n</span><span class="s1"> </span><span class="si">{</span><span class="n">categorical_cols</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Columns in original DataFrame:&quot;</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

                <span class="c1"># Drop the original categorical columns from the dataframe</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">categorical_cols</span><span class="p">)</span>

                <span class="c1"># Concatenate the original dataframe with the one-hot encoded columns</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Columns in one-hot encoded DataFrame:&quot;</span><span class="p">,</span> <span class="n">one_hot_encoded</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">one_hot_encoded</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Convert back to a dataframe</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s2">&quot;Processing complete.&quot;</span><span class="p">)</span>  

            <span class="k">return</span> <span class="n">df</span></div>
        
<div class="viewcode-block" id="Process.interpolate_point_to_raster"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.interpolate_point_to_raster">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_point_to_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_data_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">from_crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">to_crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lon_column</span><span class="o">=</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">lat_column</span><span class="o">=</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">output_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">processing_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_resolution</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolates point-based data to a raster grid, optionally within a specified boundary.</span>
<span class="sd">        </span>
<span class="sd">        This function reads the point-based spatial data, interpolates it using Ordinary Kriging, and then exports it to a raster file.</span>
<span class="sd">        It also allows for specifying a boundary within which the interpolation is to be done.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X_data_folder (str, optional): Path to the folder containing the point-based data. Defaults to `self.X_data_folder`.</span>
<span class="sd">            columns (list, optional): List of columns to read from the data. Defaults to None.</span>
<span class="sd">            from_crs (str, optional): Coordinate Reference System of the original data. Defaults to &quot;EPSG:4326&quot;.</span>
<span class="sd">            to_crs (str, optional): Coordinate Reference System to convert the data into. Defaults to None.</span>
<span class="sd">            lon_column (str, optional): Column name for longitude. Defaults to &#39;lon&#39;.</span>
<span class="sd">            lat_column (str, optional): Column name for latitude. Defaults to &#39;lat&#39;.</span>
<span class="sd">            output_folder (str, optional): Path to the folder where the raster files will be saved. Defaults to `self.processing_folder`.</span>
<span class="sd">            processing_folder (str, optional): Path to the processing folder. Defaults to `self.processing_folder`.</span>
<span class="sd">            grid_resolution (float, optional): Grid resolution for raster files in decimal degrees. Defaults to 0.25.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            Exception: If no boundary file is found in the provided folder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">X_data_folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">X_data_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_data_folder</span>
        <span class="k">if</span> <span class="n">output_folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span> 
        <span class="k">if</span> <span class="n">processing_folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>   
            <span class="n">processing_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span>   

        <span class="k">def</span> <span class="nf">mask_tif_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">boundary</span><span class="p">):</span>
            <span class="n">clipped</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boundary</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">mapping</span><span class="p">),</span> <span class="n">boundary</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">clipped</span>
        
        <span class="c1"># Reads in the csv from X_data_folder and filters it to columns</span>
        <span class="n">raw_X_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">read_X_data</span><span class="p">(</span><span class="n">X_data_folder</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

        <span class="c1"># Sort columnwise alphabetically</span>
        <span class="c1"># To ensure column order is the same as future data we use to predict </span>
        <span class="c1"># (which is sorted in the same way in modeling.predict_and_plot_raster and modeling.predict_and_plot_gdf)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s1">&#39;Sorting the X dataframe columnwise.&#39;</span><span class="p">)</span>
        <span class="n">raw_X_data</span> <span class="o">=</span> <span class="n">raw_X_data</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;raw_X_data.columns </span><span class="si">{</span><span class="n">raw_X_data</span><span class="o">.</span><span class="n">columns</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Convert the data into a GeoDataFrame</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;creating gdf&#39;</span><span class="p">)</span>
        <span class="n">geodataframe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">df_to_gdf_point</span><span class="p">(</span><span class="n">raw_X_data</span><span class="p">,</span> <span class="n">lon_column</span><span class="o">=</span><span class="n">lon_column</span><span class="p">,</span> <span class="n">lat_column</span><span class="o">=</span><span class="n">lat_column</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">from_crs</span><span class="p">,</span> <span class="n">drop_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to_crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geodataframe</span> <span class="o">=</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">to_crs</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;geodataframe&#39;</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">geodataframe</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected_cols</span> <span class="o">=</span> <span class="n">geodataframe</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">geom_cols</span> <span class="o">=</span> <span class="n">geodataframe</span><span class="p">[[</span><span class="n">lon_column</span><span class="p">,</span> <span class="n">lat_column</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>   
            <span class="n">geodataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">geom_cols</span><span class="p">,</span> <span class="n">selected_cols</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">geodataframe</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geodataframe</span><span class="p">)</span>   
        
        <span class="n">grid_resolution</span> <span class="o">=</span> <span class="n">grid_resolution</span> <span class="o">*</span> <span class="mi">1000</span>  <span class="c1"># Convert grid resolution to m to match crs units</span>
        <span class="n">geodataframe</span> <span class="o">=</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

        <span class="c1"># Automatically detect the boundary file format</span>
        <span class="n">boundary_filepath</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;boundary&#39;</span> <span class="ow">in</span> <span class="n">filename</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">and</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;.shp&#39;</span><span class="p">,</span> <span class="s1">&#39;.gpkg&#39;</span><span class="p">,</span> <span class="s1">&#39;.tab&#39;</span><span class="p">)):</span>
                <span class="n">boundary_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
                <span class="c1"># Read the boundary GeoDataFrame using geopandas</span>
                <span class="n">boundary</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">boundary_filepath</span><span class="p">)</span>

                <span class="c1"># Check is the coordinates are in the same reference system and if not, convert the boundary crs to match. </span>
                <span class="k">if</span> <span class="n">boundary</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&#39;&#39;Warning: Data CRS: </span><span class="si">{</span><span class="n">geodataframe</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s1"> doesn</span><span class="se">\&#39;</span><span class="s1">t match the boundary</span><span class="se">\&#39;</span><span class="s1">s: </span><span class="si">{</span><span class="n">boundary</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s1">.</span><span class="se">\n</span>
<span class="s1">                          Converting the boundary crs to match the data</span><span class="se">\&#39;</span><span class="s1">s.&#39;&#39;&#39;</span><span class="p">)</span>
                    <span class="n">boundary</span> <span class="o">=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">geodataframe</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

                <span class="k">break</span>
        <span class="k">if</span> <span class="n">boundary_filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No boundary file found in the provided folder&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;starting interpolation&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>   
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;NAME&#39;</span><span class="p">,</span> <span class="s1">&#39;SITE&#39;</span><span class="p">,</span> <span class="n">lon_column</span><span class="p">,</span> <span class="n">lat_column</span><span class="p">,</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Interpolating variable: </span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="c1"># Extract values and coordinates</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">geodataframe</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span>

                <span class="c1"># Create a grid to store interpolated values</span>
                <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">total_bounds</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">grid_resolution</span><span class="p">)</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">grid_resolution</span><span class="p">)</span>
                <span class="n">x_grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">grid_resolution</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">)]</span>
                <span class="n">y_grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">grid_resolution</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>

                <span class="n">kriging</span> <span class="o">=</span> <span class="n">OrdinaryKriging</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">variogram_model</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">enable_plotting</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                
                <span class="n">interpolated</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">kriging</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;grid&quot;</span><span class="p">,</span> <span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">)</span>

                <span class="n">transform</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">grid_resolution</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">grid_resolution</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)</span>

                <span class="c1"># Create an output folder for the raw raster data</span>
                <span class="n">raw_output_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span> <span class="s1">&#39;interpolated_rasters&#39;</span><span class="p">)</span>

                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">raw_output_folder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">output_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">raw_output_folder</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s1">.tif&#39;</span><span class="p">)</span>

                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;GTiff&#39;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">dtype</span><span class="o">=</span><span class="n">interpolated</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">to_crs</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                    <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">interpolated</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                
                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                    <span class="n">interpolated_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Masking the raster if boundary is provided</span>
                <span class="k">if</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Boundary file: </span><span class="si">{</span><span class="n">boundary_filepath</span><span class="si">}</span><span class="s1"> detected, masking the data to the boundary.&#39;</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">rxr</span><span class="o">.</span><span class="n">open_rasterio</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                    <span class="n">clipped</span> <span class="o">=</span> <span class="n">mask_tif_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
                    <span class="n">clipped</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">to_raster</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>  <span class="c1"># Overwrite the existing raster</span>
                    <span class="n">interpolated_data</span> <span class="o">=</span> <span class="n">clipped</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># Update for plotting</span>

                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                    <span class="n">interpolated_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     

                <span class="c1"># Plot interpolated grid</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">interpolated_data</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">variable</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Interpolated - </span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
                <span class="n">fig_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span> <span class="s1">&#39;interpolated_rasters/maps&#39;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">fig_folder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">fig_folder</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s1">.png&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Interpolated data exported to raster file:&quot;</span><span class="p">,</span> <span class="n">output_file</span><span class="p">)</span></div>
                        
    <span class="c1"># Convert day columns to datetime format</span>
<div class="viewcode-block" id="Process.day_to_datetime"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.day_to_datetime">[docs]</a>    <span class="k">def</span> <span class="nf">day_to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">base_date</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert day columns in the DataFrame to datetime format.</span>
<span class="sd">        </span>
<span class="sd">        Args:pri</span>
<span class="sd">            df (pd.DataFrame): The input DataFrame containing day columns.</span>
<span class="sd">            base_date (datetime, optional): The base date from which to calculate the actual dates. Defaults to January 1, 2021.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: DataFrame with day columns converted to datetime format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">day_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Day_&#39;</span><span class="p">)]</span>
        <span class="n">day_numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">day_columns</span><span class="p">]</span>
        <span class="n">date_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">base_date</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">day_number</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">day_number</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">day_columns</span><span class="p">,</span> <span class="n">day_numbers</span><span class="p">)}</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">date_mapping</span><span class="p">)</span>  

        <span class="k">return</span> <span class="n">df</span></div>
    
<div class="viewcode-block" id="Process.del_time_dimension"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.del_time_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">del_time_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes the temporal dimension of a DataFrame by removing the &#39;Day&#39; column and reordering NaNs within each &#39;site&#39; group.</span>
<span class="sd">        </span>
<span class="sd">        The purpose of this is to handle the data collection technique of rotating sensors around the study area. </span>
<span class="sd">        This technique results in patchy data spatially and temporally. </span>

<span class="sd">        Dropping the time dimension essentially condenses the data into a single survey, </span>
<span class="sd">        containing recordings over space while disregarding when the recordings were made. </span>

<span class="sd">        This function takes a DataFrame with a &#39;site&#39; column, a &#39;Day&#39; column (time dimension), and one or more additional columns (presumed to be species data or similar). The function performs the following operations:</span>
<span class="sd">        </span>
<span class="sd">        1. Identifies columns that are neither &#39;site&#39; nor &#39;Day&#39;.</span>
<span class="sd">        2. Sorts each of these columns within each &#39;site&#39; group to place NaNs at the end, while preserving the relative order of other values.</span>
<span class="sd">        3. Removes rows where all of the identified columns have NaN values.</span>
<span class="sd">        4. Removes rows where all columns (including &#39;site&#39;) are NaN.</span>
<span class="sd">        5. Deletes the &#39;Day&#39; column.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            df (pandas.DataFrame): The input DataFrame containing &#39;site&#39;, &#39;Day&#39;, and other relevant columns.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame: A DataFrame with the time dimension removed and NaNs reorganized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deleting the time dimension.&quot;</span><span class="p">)</span>
        <span class="c1"># Select the species columns</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;site&#39;</span><span class="p">,</span> <span class="s1">&#39;Day&#39;</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;Day&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>
    
<div class="viewcode-block" id="Process.check_balance_na"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.check_balance_na">[docs]</a>    <span class="k">def</span> <span class="nf">check_balance_na</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">sort_by</span><span class="o">=</span><span class="s1">&#39;1 Count&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check and summarize the balance and missing values within the DataFrame.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame): The input DataFrame.</span>
<span class="sd">            sort_by (str, optional): The column by which to sort the summary. Defaults to &#39;1 Count&#39;.</span>
<span class="sd">            ascending (bool, optional): Sorting order. Defaults to True.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: A summary DataFrame showing balance and missing data stats.</span>
<span class="sd">        Notes: This function assumes binary data, so is not suitable if values have been filled with decimal values </span>
<span class="sd">                (it is used before this point in the y data pipeline)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Count the number of NaN values per column</span>
        <span class="n">na_counts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">non_na_counts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

        <span class="c1"># Calculate the total count of values in each column</span>
        <span class="n">total_counts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="c1"># Calculate the percentage of missing values per column</span>
        <span class="n">missing_percentages</span> <span class="o">=</span> <span class="p">(</span><span class="n">na_counts</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span>

        <span class="c1"># Calculate the count of 0 values in each column</span>
        <span class="n">zero_counts</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

        <span class="c1"># Calculate the count of 1 values in each column</span>
        <span class="n">one_counts</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

        <span class="c1"># Calculate the % ratio of 1 values to 0 values</span>
        <span class="n">balance_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">one_counts</span> <span class="o">/</span> <span class="n">zero_counts</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

        <span class="c1"># Create a new DataFrame to store the results</span>
        <span class="n">df_summary</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;NA Count&#39;</span><span class="p">:</span> <span class="n">na_counts</span><span class="p">,</span> <span class="s1">&#39;non-NA Count&#39;</span><span class="p">:</span> <span class="n">non_na_counts</span><span class="p">,</span> <span class="s1">&#39;Total Count&#39;</span><span class="p">:</span> <span class="n">total_counts</span><span class="p">,</span> <span class="s1">&#39;Missing %&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">missing_percentages</span><span class="p">),</span>
                                <span class="s1">&#39;0 Count&#39;</span><span class="p">:</span> <span class="n">zero_counts</span><span class="p">,</span> <span class="s1">&#39;1 Count&#39;</span><span class="p">:</span> <span class="n">one_counts</span><span class="p">,</span> <span class="s1">&#39;Balance Score&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">balance_score</span><span class="p">,</span> <span class="mi">2</span><span class="p">)})</span>
        
        <span class="n">df_summary</span> <span class="o">=</span> <span class="n">df_summary</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_summary</span></div>
    
<div class="viewcode-block" id="Process.filter_on_missing"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.filter_on_missing">[docs]</a>    <span class="k">def</span> <span class="nf">filter_on_missing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the input DataFrame based on a missing percentage threshold.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame): The input DataFrame.</span>
<span class="sd">            threshold (int): The missing percentage threshold.</span>
<span class="sd">            drop (bool, optional): Whether to drop columns exceeding the threshold from the original DataFrame. Defaults to True.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Filtered DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="c1"># Create a table summarising missing data for each species</span>
        <span class="n">check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_balance_na</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="c1"># Filter the table based on the missing % threshold</span>
        <span class="n">overly_na_data</span> <span class="o">=</span> <span class="n">check</span><span class="p">[</span><span class="n">check</span><span class="p">[</span><span class="s1">&#39;Missing %&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;Missing %&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">#Exclude &quot;site&quot; column from being checked</span>
        <span class="n">overly_na_data</span> <span class="o">=</span> <span class="n">overly_na_data</span><span class="p">[</span><span class="o">~</span><span class="n">overly_na_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s1">&#39;site&#39;</span><span class="p">,</span> <span class="s1">&#39;Day&#39;</span><span class="p">])]</span>

        <span class="c1"># Drop records that have missing % greater than or equal to the threshold</span>
        <span class="k">if</span> <span class="n">drop</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Dropping the below species from the dataset.&#39;</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">overly_na_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Species with missing percentage above the threshold: </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">%:&#39;</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">overly_na_data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="Process.filter_on_balance"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.filter_on_balance">[docs]</a>    <span class="k">def</span> <span class="nf">filter_on_balance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the input DataFrame based on either the count of presence records or the Balance Score.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame): The input DataFrame.</span>
<span class="sd">            threshold (int): The threshold for either count of presence records or Balance Score.</span>
<span class="sd">            score (bool, optional): If True, uses Balance Score for filtering. Otherwise, uses count of presence records. Defaults to False.</span>
<span class="sd">            drop (bool, optional): Whether to drop columns not meeting the threshold from the original DataFrame. Defaults to True.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Filtered DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a table summarising missing data for each species</span>
        <span class="n">check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_balance_na</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        
        <span class="c1"># Filter the table based on either the count of presence records or the Balance Score</span>
        <span class="k">if</span> <span class="n">score</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span> 
            <span class="n">overly_imba_data</span> <span class="o">=</span> <span class="n">check</span><span class="p">[</span><span class="n">check</span><span class="p">[</span><span class="s1">&#39;1 Count&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;1 Count&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>            
        <span class="k">elif</span> <span class="n">score</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> 
            <span class="n">overly_imba_data</span> <span class="o">=</span> <span class="n">check</span><span class="p">[</span><span class="n">check</span><span class="p">[</span><span class="s1">&#39;Balance Score&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;Balance Score&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">#Exclude &quot;site&quot; column from being checked </span>
        <span class="n">overly_imba_data</span> <span class="o">=</span> <span class="n">overly_imba_data</span><span class="p">[</span><span class="o">~</span><span class="n">overly_imba_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s1">&#39;site&#39;</span><span class="p">,</span> <span class="s1">&#39;Day&#39;</span><span class="p">])]</span>
        
        <span class="k">if</span> <span class="n">drop</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Dropping the below species from the dataset.&#39;</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">overly_imba_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">score</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Species with imbalance below the balance_score threshold: </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Species with count of presence records below the threshold: </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">display</span><span class="p">(</span><span class="n">overly_imba_data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="Process.get_csv_paths"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.get_csv_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_csv_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">species_filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">species_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of filepaths of CSV files that contain any of the species in the given list.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        - species_filepath (str): The path to the folder containing the CSV files.</span>
<span class="sd">        - species_list (list, optional): A list of species to filter the CSV files by. If None, reads all CSV files.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - List[str]: A list of filepaths of the relevant CSV files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">species_filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">species_filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_data_folder</span>

        <span class="n">matching_filepaths</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Convert species list to lowercase for case insensitivity</span>
        <span class="k">if</span> <span class="n">species_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">species_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">species_list</span><span class="p">]</span>

        <span class="c1"># Walk through the folder and subfolders</span>
        <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">species_filepath</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                <span class="c1"># Check if the file is a CSV</span>
                <span class="k">if</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;*.csv&#39;</span><span class="p">):</span>
                    <span class="c1"># If no species list is provided, add all CSV file paths</span>
                    <span class="k">if</span> <span class="n">species_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">matching_filepaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Check if the filename contains any of the species</span>
                        <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">species_list</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">filename</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                                <span class="c1"># Add the full file path to the list</span>
                                <span class="n">matching_filepaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>
                                <span class="k">break</span>
        
        <span class="k">return</span> <span class="n">matching_filepaths</span></div>
        
<div class="viewcode-block" id="Process.preprocess_y_data"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.preprocess_y_data">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess_y_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">folder_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">species_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">balance_threshold</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">del_time</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocesses CSV data files containing species observation data based on the folder they reside in and returns a single processed DataFrame.</span>

<span class="sd">        This method is designed to handle specific CSV data files located within folders.</span>
<span class="sd">        The preprocessing applied to the data includes applying missing data thresholds, balance thresholds, and optionally deleting the time dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            folder_path (str, optional): Path to the directory where the data folders are located.</span>
<span class="sd">                If not provided, the method retrieves a default path stored within the class.</span>
<span class="sd">            species_list (list, optional): A list of species names to be included in the processed DataFrame.</span>
<span class="sd">                If not provided, all species found in the CSV files will be included.</span>
<span class="sd">            missing_threshold (int, optional): Percentage threshold to filter out columns with missing data</span>
<span class="sd">                greater than this threshold. Defaults to 0.</span>
<span class="sd">            balance_threshold (int, optional): Threshold to filter out columns based on the balance score.</span>
<span class="sd">                Defaults to 20.</span>
<span class="sd">            del_time (bool, optional): Flag indicating whether to delete the time dimension. Defaults to True.</span>
<span class="sd">            verbose (bool, optional): Flag indicating whether to print informational messages during processing. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: A processed DataFrame containing the concatenated and cleaned data from all the input CSV files.</span>

<span class="sd">        Key Functionalities:</span>
<span class="sd">            - Reads CSV files from a given directory and applies specific preprocessing such as missing data and balance thresholds.</span>
<span class="sd">            - Optionally removes the time dimension if del_time is True.</span>
<span class="sd">            - Aggregates and concatenates all the processed data.</span>
<span class="sd">            - Can filter data by species if a species_list is provided.</span>
<span class="sd">        </span>
<span class="sd">        Notes:</span>
<span class="sd">            - Removes data with fewer examples than the balance_threshold to prevent errors when trying to split the data into train/validation/test datasets.</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; preprocess_y_data(missing_threshold=40, balance_threshold=40, folder_path=&#39;./data/folders&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Purposely not using a class here to make the syntax to call the function more readable for the end user</span>
        <span class="c1"># E.G. Preprocess().preprocess_y_data(&#39;folder&#39;)</span>
        <span class="c1"># not  Preprocess().preprocess_y_data(Preprocess(), &#39;folder&#39;)</span>

        <span class="c1"># Suppress all outputs if verbose is False</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">suppress_output</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span> <span class="k">else</span> <span class="n">nullcontext</span><span class="p">():</span>

            <span class="c1"># Check if a specific folder path was provided</span>
            <span class="k">if</span> <span class="n">folder_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">folder_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_data_folder</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s2">&quot;Getting y_folder path from the class for processing.</span><span class="se">\n</span><span class="si">{folder_path}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using provided folder path for processing.</span><span class="se">\n</span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="c1"># Processing for data from the folder 2021</span>
            <span class="k">def</span> <span class="nf">specific_processing_2021</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Apply preprocessing steps specific to data from the 2021 folder.</span>
<span class="sd">                </span>
<span class="sd">                Args:</span>
<span class="sd">                    df (pd.DataFrame): The input DataFrame containing raw data from the 2021 folder.</span>
<span class="sd">                    file_name (str): The name of the file currently being processed.</span>
<span class="sd">                    </span>
<span class="sd">                Returns:</span>
<span class="sd">                    pd.DataFrame: The processed DataFrame.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing 2021 data for species: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;SITE&#39;</span><span class="p">:</span> <span class="s1">&#39;site&#39;</span><span class="p">})</span>
                <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">day_to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                <span class="n">val_name</span> <span class="o">=</span> <span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;_isPresent&#39;</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;site&#39;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Day&#39;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="n">val_name</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">df</span>

            <span class="c1"># Processing for data from the folder 2022</span>
            <span class="k">def</span> <span class="nf">specific_processing_2022</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Apply preprocessing steps specific to data from the 2022 folder.</span>
<span class="sd">                </span>
<span class="sd">                Args:</span>
<span class="sd">                    df (pd.DataFrame): The input DataFrame containing raw data from the 2022 folder.</span>
<span class="sd">                    file_name (str): The name of the file currently being processed.</span>
<span class="sd">                    </span>
<span class="sd">                Returns:</span>
<span class="sd">                    pd.DataFrame: The processed DataFrame.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing 2022 data for species: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">val_name</span> <span class="o">=</span> <span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;_isPresent&#39;</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;site&#39;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Day&#39;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="n">val_name</span><span class="p">)</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Day&#39;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">df</span>
            
            <span class="k">def</span> <span class="nf">specific_processing_GBIF</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing 2022 data for species: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">val_name</span> <span class="o">=</span> <span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;_isPresent&#39;</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;site&#39;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Day&#39;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="n">val_name</span><span class="p">)</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Day&#39;</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">df</span>                        
            <span class="c1"># Core processing function (makes calls to the other functions within preprocess_y_data)</span>
            <span class="c1"># Dynamically map folder names to their specific preprocessing methods</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Mapping folder names to their respective processing methods</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Initialize the preprocessors dictionary</span>
            <span class="n">preprocessors</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># Populate the preprocessors dictionary</span>
            <span class="k">for</span> <span class="n">folder_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">)):</span>
                    <span class="n">preprocessors</span><span class="p">[</span><span class="n">folder_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;specific_processing_&quot;</span> <span class="o">+</span> <span class="n">folder_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Mapping completed.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Process each CSV file</span>
            <span class="k">def</span> <span class="nf">process_files</span><span class="p">():</span>
                    <span class="n">csv_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_csv_paths</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">species_list</span><span class="p">)</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s2">&quot;Starting processing of CSV files</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">first_file</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">csv_files</span><span class="p">:</span>
                            
                        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">first_file</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unprocessed file example:&quot;</span><span class="p">)</span>
                            <span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>

                        <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;occupancy-models-export_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_PRIW&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;(1)&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                        <span class="n">file_name</span> <span class="o">=</span> <span class="n">file_name</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>

                        <span class="c1"># Get the folder name </span>
                        <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>

                        <span class="c1"># Look in the preprocessors dictionary for a function with a name in the format: specific_processing_&#39;parent_directory&#39; and apply it to that folder&#39;s data.</span>
                        <span class="c1"># This function can be extended for future survey folders if they require different preprocessing by adding a new function named in this format.</span>
                        <span class="k">if</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">preprocessors</span> <span class="ow">and</span> <span class="n">preprocessors</span><span class="p">[</span><span class="n">folder</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">df</span> <span class="o">=</span> <span class="n">preprocessors</span><span class="p">[</span><span class="n">folder</span><span class="p">](</span><span class="n">df</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying specific processing for the folder </span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                        <span class="c1"># If there is a folder of data with no preprocessing defined, still apply the below minimal processing.</span>
                        <span class="c1"># This processing must also be added to any new specific functions either before or after other specific processing steps.</span>
                        <span class="c1"># Applying pd.melt during this loop before concatenation dramatically reduces the RAM required to run the code. </span>
                        <span class="k">elif</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">preprocessors</span> <span class="ow">and</span> <span class="n">preprocessors</span><span class="p">[</span><span class="n">folder</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
                            <span class="n">val_name</span> <span class="o">=</span> <span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;_isPresent&#39;</span>
                            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;site&#39;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Day&#39;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="n">val_name</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="n">first_file</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed file example:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
                
                        <span class="c1">#print(&quot;Replacing values and sorting the data.&quot;)  </span>
                        <span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;NA&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;site&#39;</span><span class="p">,</span> <span class="s1">&#39;Day&#39;</span><span class="p">])</span>
                        <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                        <span class="n">first_file</span> <span class="o">=</span> <span class="kc">False</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s2">&quot;Concatenating all processed dataframes.&quot;</span><span class="p">)</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="s2">&quot;Day&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

                    <span class="c1"># Delete the time dimension</span>
                    <span class="k">if</span> <span class="n">del_time</span><span class="p">:</span> 
                        <span class="c1"># This is important for dealing with the data&#39;s survey technique, please read the documentation for more information. </span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Missing data before removing the time dimension:&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">plot_missing_data</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">del_time_dimension</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Missing data after removing the time dimension:&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">plot_missing_data</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Processing completed!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> 

                    <span class="c1"># Filter data based on NA and imbalance thresholds </span>
                    <span class="k">if</span> <span class="n">missing_threshold</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_on_missing</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">missing_threshold</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">balance_threshold</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_on_balance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">balance_threshold</span><span class="p">)</span>

                    <span class="c1"># Print summary information about the processed data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data row and column count:</span><span class="se">\n</span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data example:&quot;</span><span class="p">)</span>
                    <span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s2">&quot;Data balance and missing values:&quot;</span><span class="p">)</span>
                    <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_balance_na</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s1">&#39;y_data preprocessing complete&#39;</span><span class="p">)</span>

                    <span class="k">return</span> <span class="n">df</span>
            <span class="k">return</span> <span class="n">process_files</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="Process.join_X_to_y"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.join_X_to_y">[docs]</a>    <span class="k">def</span> <span class="nf">join_X_to_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;site&#39;</span><span class="p">,</span> <span class="n">output_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges two dataframes based on the &quot;on&quot; column and identifies unmatched keys.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - x: DataFrame containing environmental data.</span>
<span class="sd">        - y: DataFrame containing species data.</span>
<span class="sd">        - output_folder: Path to the directory where the unmatched keys csv will be saved.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - DataFrame: Merged dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">output_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_folder</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Inner joining X data to y data based on the </span><span class="si">{</span><span class="n">on</span><span class="si">}</span><span class="s1"> column. </span><span class="se">\n</span><span class="s1">Saving validation report to: </span><span class="si">{</span><span class="n">output_folder</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Join the data based on the &quot;site&quot; column</span>
        <span class="n">merged_data</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>

        <span class="c1"># Get the unique keys that didn&#39;t match</span>
        <span class="n">unmatched_keys_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">y</span><span class="p">[</span><span class="n">on</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">on</span><span class="p">]),</span> <span class="n">on</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unmatched_keys_y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">unmatched_keys_y</span><span class="p">)</span>
        <span class="n">unmatched_keys_y</span><span class="p">[</span><span class="s1">&#39;Direction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;site found in Species data but not in the Environmental data&#39;</span>

        <span class="n">unmatched_keys_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">x</span><span class="p">[</span><span class="n">on</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">on</span><span class="p">]),</span> <span class="n">on</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">unmatched_keys_x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">unmatched_keys_x</span><span class="p">)</span>
        <span class="n">unmatched_keys_x</span><span class="p">[</span><span class="s1">&#39;Direction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;site found in Environmental data but not in the Species data&#39;</span>

        <span class="c1"># Append arrays</span>
        <span class="n">unmatched_keys</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">unmatched_keys_y</span><span class="p">,</span> <span class="n">unmatched_keys_x</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Generate a warning if there are unmatched keys</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmatched_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Some sites did not match between the Species and the Environment data: </span><span class="si">{</span><span class="n">unmatched_keys</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">unmatched_keys</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span> <span class="s1">&#39;Unmatched keys (Species-environment join).csv&#39;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">merged_data</span></div>

<div class="viewcode-block" id="Process.fill_na_with_xgboost"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.fill_na_with_xgboost">[docs]</a>    <span class="k">def</span> <span class="nf">fill_na_with_xgboost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">lon_col</span><span class="o">=</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">lat_col</span><span class="o">=</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s1">&#39;isPresent&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses XGBoost to predict and fill NA values for specific columns based on coordinates.</span>
<span class="sd">        </span>
<span class="sd">        This function leverages the power of the XGBoost algorithm to make predictions for the columns </span>
<span class="sd">        in the DataFrame containing NA values. The primary predictors for these columns are coordinates. </span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        - df (pd.DataFrame): The input dataframe that contains the data with potential NA values.</span>
<span class="sd">        - lon_col (str): The name of the column that represents the longitude. Defaults to &#39;lon&#39;.</span>
<span class="sd">        - lat_col (str): The name of the column that represents the latitude. Defaults to &#39;lat&#39;.</span>
<span class="sd">        - pattern (str): The pattern or substring to search in the columns to identify which ones need processing. Defaults to &#39;isPresent&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        - pd.DataFrame: A DataFrame with NA values predicted and filled using XGBoost.</span>
<span class="sd">        </span>
<span class="sd">        Note:</span>
<span class="sd">            Only columns that have the provided pattern in their name, are numerical, and contain NA values </span>
<span class="sd">            will be processed. Ensure that the DataFrame has at least some non-NA values in these columns for </span>
<span class="sd">            the model to be trained and make predictions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feature_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">lon_col</span><span class="p">,</span> <span class="n">lat_col</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">target_column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Check if the column is a numerical y column with any NAs to fill</span>
            <span class="k">if</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">target_column</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># Split data into train and predict dfs</span>
                <span class="n">df_train</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">target_column</span><span class="p">])</span>
                <span class="n">df_predict</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span>

                <span class="n">X_train</span> <span class="o">=</span> <span class="n">df_train</span><span class="p">[</span><span class="n">feature_columns</span><span class="p">]</span>
                <span class="n">Y_train</span> <span class="o">=</span> <span class="n">df_train</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span>

                <span class="n">X_predict</span> <span class="o">=</span> <span class="n">df_predict</span><span class="p">[</span><span class="n">feature_columns</span><span class="p">]</span>

                <span class="c1"># Train XGBoost model</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">XGBRegressor</span><span class="p">(</span><span class="n">objective</span> <span class="o">=</span><span class="s1">&#39;reg:squarederror&#39;</span><span class="p">)</span>
                <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">)</span>

                <span class="c1"># Predict NA values</span>
                <span class="n">Y_predict</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_predict</span><span class="p">)</span>

                <span class="c1"># Round Y_predict to 2 decimal places</span>
                <span class="n">Y_predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Y_predict</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># Clip values between 0 and 1</span>
                <span class="n">Y_predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">Y_predict</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Fill NA values in original df</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="n">target_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">Y_predict</span>           

        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="Process.fill_na_with_avg"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.fill_na_with_avg">[docs]</a>    <span class="k">def</span> <span class="nf">fill_na_with_avg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s1">&#39;isPresent&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills NA values for specific columns in a DataFrame with the average of their respective site&#39;s values.</span>

<span class="sd">        This function replaces NA values in columns containing the &#39;isPresent&#39; pattern with the average of </span>
<span class="sd">        non-NA values for that column within each site. This operation is done in a site-specific manner and </span>
<span class="sd">        does not affect sites that have no records for a species.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - df (pd.DataFrame): The DataFrame containing the data with potential NA values.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - pd.DataFrame: A DataFrame with NA values replaced by the site-specific average for columns with the &#39;isPresent&#39; pattern.</span>

<span class="sd">        Note:</span>
<span class="sd">            Only columns that contain the pattern and are of a numeric datatype are processed.</span>
<span class="sd">            Ensure that the DataFrame has the &#39;site&#39; column available as it is used for grouping data.</span>
<span class="sd">            Does not affect sites with no records for a species</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Filling missing values for each species with each site</span><span class="se">\&#39;</span><span class="s1">s average value for that species&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">column</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
                <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;site&#39;</span><span class="p">)[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>
    
<div class="viewcode-block" id="Process.xy_split"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.xy_split">[docs]</a>    <span class="k">def</span> <span class="nf">xy_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s1">&#39;isPresent&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits a DataFrame into two datasets based on the presence of a specified pattern in column names.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame): The DataFrame to be split.</span>
<span class="sd">            pattern (str, optional): The string pattern to split columns on. Defaults to &#39;isPresent&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame, pd.DataFrame: Two DataFrames - X containing columns without the pattern and y containing columns with the pattern.</span>

<span class="sd">        Note:</span>
<span class="sd">            Ensure that the DataFrame does not contain columns other than features and labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Sort columnwise alphabetically</span>
        <span class="c1"># To ensure column order is the same as future data we use to predict </span>
        <span class="c1"># (which is sorted in the same way in modeling.predict_and_plot_raster and modeling.predict_and_plot_gdf)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="s1">&#39;Sorting the X dataframe columnwise.&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Splitting data into X and y datasets based on whether the column names contain </span><span class="si">{</span><span class="n">pattern</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">mask</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="o">~</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="c1"># Convert y to a df incase it&#39;s a series (predicting for a single species)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of classes (species) = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;X shape:</span><span class="se">\n</span><span class="si">{</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;X data example:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;y shape:</span><span class="se">\n</span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;y data example:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span></div>
    
<div class="viewcode-block" id="Process.multi_label_split"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.multi_label_split">[docs]</a>    <span class="k">def</span> <span class="nf">multi_label_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">val_size</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.15</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a multilabel stratified split of the dataset into train, validation, and test sets.</span>

<span class="sd">        This function ensures that each label (species) is fairly represented in each set to maintain </span>
<span class="sd">        consistency in label distributions across the splits.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (pd.DataFrame): Feature matrix.</span>
<span class="sd">            y (pd.DataFrame): Label matrix.</span>
<span class="sd">            val_size (float, optional): Proportion of the dataset to include in the validation set. Defaults to 0.15.</span>
<span class="sd">            test_size (float, optional): Proportion of the dataset to include in the test set. Defaults to 0.15.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: Returns six DataFrames - X_train, y_train, X_val, y_val, X_test, and y_test.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `val_size` and `test_size` combined are greater than 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Performing multilabel stratified splitting into train, test, and validation sets.</span><span class="se">\n</span><span class="s1">This type of splitting aims to ensure each species is fairly represented in each set.&#39;</span><span class="p">)</span>
        <span class="n">X_values</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">values</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">values</span>

        <span class="n">test_size_1</span> <span class="o">=</span> <span class="n">test_size</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">val_size</span><span class="p">)</span>
        <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">iterative_train_test_split</span><span class="p">(</span><span class="n">X_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size_1</span><span class="p">)</span>
        
        <span class="n">test_size_2</span> <span class="o">=</span> <span class="n">val_size</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">test_size</span><span class="p">)</span>
        <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span> <span class="o">=</span> <span class="n">iterative_train_test_split</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size_2</span><span class="p">)</span>

        <span class="c1"># Add the column names back to the data</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">X_val</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X_val</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">y_val</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;X_train.shape: </span><span class="si">{</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;X_val.shape: </span><span class="si">{</span><span class="n">X_val</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;X_test.shape: </span><span class="si">{</span><span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;y_train.shape: </span><span class="si">{</span><span class="n">y_train</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;y_val.shape: </span><span class="si">{</span><span class="n">y_val</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;y_test.shape: </span><span class="si">{</span><span class="n">y_test</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span></div>
    
<div class="viewcode-block" id="Process.balance_dataset_MLSMOTE"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.balance_dataset_MLSMOTE">[docs]</a>    <span class="k">def</span> <span class="nf">balance_dataset_MLSMOTE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">n_sample</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Balance a multi-label dataset using Multi-label SMOTE.</span>

<span class="sd">        This function uses the Multi-label Synthetic Minority Over-sampling Technique (SMOTE)</span>
<span class="sd">        to generate synthetic samples and balance the dataset for multi-label classification problems.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X_train (pd.DataFrame): The feature matrix of the training dataset.</span>
<span class="sd">            y_train (pd.DataFrame): The label matrix of the training dataset.</span>
<span class="sd">            n_sample (int, optional): The number of synthetic samples to be generated. Defaults to 100.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame, pd.DataFrame: The balanced feature and label matrices of the training dataset.</span>

<span class="sd">        Note:</span>
<span class="sd">            The function checks for the presence of the &#39;mlsmote.py&#39; file, and downloads it if not found.</span>
<span class="sd">            Ensure you have appropriate permissions and internet connectivity before using this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Check if the &#39;mlsmote.py&#39; file exists. If not, download it to the current directory.</span>
            <span class="n">download_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;mlsmote.py&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">download_path</span><span class="p">):</span>
                <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/niteshsukhwani/MLSMOTE/master/mlsmote.py&quot;</span>
                <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

                <span class="c1"># Ensure we got a successful response</span>
                <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;mlsmote.py&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to download mlsmote.py. HTTP Status Code: </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="c1"># Import the mlsmote .py file</span>
            <span class="kn">from</span> <span class="nn">mlsmote</span> <span class="kn">import</span> <span class="n">get_minority_instace</span><span class="p">,</span> <span class="n">nearest_neighbour</span>

            <span class="c1"># Helper function: MLSMOTE</span>
            <span class="k">def</span> <span class="nf">MLSMOTE</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n_sample</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Generate synthetic samples for minority instances in a multi-label dataset using the Multi-label SMOTE technique.</span>
<span class="sd">                </span>
<span class="sd">                Args:</span>
<span class="sd">                X (pd.DataFrame): The feature matrix.</span>
<span class="sd">                y (pd.DataFrame): The label matrix.</span>
<span class="sd">                n_sample (int): The number of synthetic samples to generate.</span>
<span class="sd">                </span>
<span class="sd">                Returns:</span>
<span class="sd">                pd.DataFrame: The synthetic feature matrix.</span>
<span class="sd">                pd.DataFrame: The synthetic label matrix.</span>
<span class="sd">                </span>
<span class="sd">                Notes:</span>
<span class="sd">                - The function identifies the nearest neighbors for each instance in X.</span>
<span class="sd">                - For each synthetic sample to be generated, it randomly selects a reference instance and one of its neighbors.</span>
<span class="sd">                - The synthetic sample&#39;s features are computed as a linear combination of the reference and the difference between the reference and its neighbor.</span>
<span class="sd">                - Labels for the synthetic samples are determined by majority voting among the nearest neighbors of the reference.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">nearest_neighbour</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="n">new_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_sample</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_sample</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sample</span><span class="p">):</span>
                    <span class="n">reference</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">neighbour</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">reference</span><span class="p">,</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">all_point</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">reference</span><span class="p">]</span>
                    <span class="n">nn_df</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">all_point</span><span class="p">)]</span>
                    <span class="n">ser</span> <span class="o">=</span> <span class="n">nn_df</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">val</span><span class="o">&gt;</span><span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ser</span><span class="p">])</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
                    <span class="n">gap</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">reference</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">neighbour</span><span class="p">,:]</span>
                    <span class="n">new_X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">reference</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">gap</span><span class="p">)</span>
                <span class="n">new_X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">new_X</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">new_X</span><span class="p">,</span> <span class="n">target</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span><span class="se">\n</span>
<span class="s1">            Using multilabel SMOTE to add synthetic samples to the dataset based on existing samples.</span>
<span class="s1">            This process helps to balance the dataset and improves predictions for underrepresented species.</span>
<span class="s1">            Samples will (in general) contain presence recordings for the species with fewest examples of presence</span>
<span class="s1">            and absence recordings for the species with more examples of presence.</span>
<span class="s1">                  </span><span class="se">\n</span><span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
            
            <span class="n">X_sub</span><span class="p">,</span> <span class="n">y_sub</span> <span class="o">=</span> <span class="n">get_minority_instace</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
            <span class="n">X_synth</span><span class="p">,</span> <span class="n">y_synth</span> <span class="o">=</span> <span class="n">MLSMOTE</span><span class="p">(</span><span class="n">X_sub</span><span class="p">,</span> <span class="n">y_sub</span><span class="p">,</span> <span class="n">n_sample</span><span class="p">)</span>

            <span class="n">X_train_smote</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_synth</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">y_train_smote</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">y_train</span><span class="p">,</span> <span class="n">y_synth</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                
            <span class="k">return</span> <span class="n">X_train_smote</span><span class="p">,</span> <span class="n">y_train_smote</span></div>
    
<div class="viewcode-block" id="Process.export_data_to_pickle"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.export_data_to_pickle">[docs]</a>    <span class="k">def</span> <span class="nf">export_data_to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">export_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export training, testing, and validation datasets to pickle files.</span>

<span class="sd">        This function takes in data arrays for training, testing, and validation </span>
<span class="sd">        both for features (X) and labels (y) and serializes them into pickle files.</span>

<span class="sd">        Args:</span>
<span class="sd">            X_train (pd.DataFrame or np.array): Training features.</span>
<span class="sd">            X_test (pd.DataFrame or np.array): Testing features.</span>
<span class="sd">            X_val (pd.DataFrame or np.array): Validation features.</span>
<span class="sd">            y_train (pd.Series or np.array): Training labels.</span>
<span class="sd">            y_test (pd.Series or np.array): Testing labels.</span>
<span class="sd">            y_val (pd.Series or np.array): Validation labels.</span>
<span class="sd">            export_folder (str, optional): Path to the folder where pickle files will be saved.</span>
<span class="sd">                Defaults to `self.model_in_folder`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: All the input datasets are returned as they were received, in the same order.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - Make sure the export_folder exists or is writable, otherwise, the function will fail.</span>
<span class="sd">            - The function will overwrite any existing files with the same names in the `export_folder`.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; export_data_to_pickle(X_train, X_test, X_val, y_train, y_test, y_val, &quot;./data/pickle_folder&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">export_folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">export_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_in_folder</span>

        <span class="c1"># Create the export_folder if it doesn&#39;t exist</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">export_folder</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">export_folder</span><span class="p">)</span>

        <span class="c1"># Define the file paths for each pickle file</span>
        <span class="n">file_paths</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;X_train.pkl&quot;</span><span class="p">:</span> <span class="n">X_train</span><span class="p">,</span>
            <span class="s2">&quot;X_test.pkl&quot;</span><span class="p">:</span> <span class="n">X_test</span><span class="p">,</span>
            <span class="s2">&quot;X_val.pkl&quot;</span><span class="p">:</span> <span class="n">X_val</span><span class="p">,</span>
            <span class="s2">&quot;y_train.pkl&quot;</span><span class="p">:</span> <span class="n">y_train</span><span class="p">,</span>
            <span class="s2">&quot;y_test.pkl&quot;</span><span class="p">:</span> <span class="n">y_test</span><span class="p">,</span>
            <span class="s2">&quot;y_val.pkl&quot;</span><span class="p">:</span> <span class="n">y_val</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Export datasets to pickle files</span>
        <span class="k">for</span> <span class="n">filename</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">file_paths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">export_folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Data exported to pickle files successfully.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span></div>
    
<div class="viewcode-block" id="Process.main_pipeline"><a class="viewcode-back" href="../../processing.html#species_distribution_modeling.processing.Process.main_pipeline">[docs]</a>    <span class="k">def</span> <span class="nf">main_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preprocessed_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preprocessed_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">synth_count</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main data processing pipeline to preprocess, impute, balance and export data.</span>

<span class="sd">        Args:</span>
<span class="sd">            preprocessed_X (pd.DataFrame, optional): Preprocessed feature data. If not provided, will be preprocessed using default settings.</span>
<span class="sd">            preprocessed_y (pd.DataFrame, optional): Preprocessed label data. If not provided, will be preprocessed using default settings.</span>
<span class="sd">            synth_count (int, optional): Number of synthetic samples to generate using multi-label SMOTE. Defaults to 100.</span>
<span class="sd">            verbose (bool, optional): Whether or not to display detailed logs. Defaults to True.</span>

<span class="sd">        Side Effects:</span>
<span class="sd">            - Creates plots visualizing missing data.</span>
<span class="sd">            - Exports the processed datasets to pickle files.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When issues occur during SMOTE, like having zero samples.</span>
<span class="sd">            </span>
<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; main_pipeline(preprocessed_X=my_X_data, preprocessed_y=my_y_data, synth_count=200)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">preprocessed_X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">No X data passed to preprocess_X_data, preprocessing X data using default settings.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Perform X data preprocessing</span>
            <span class="n">preprocessed_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess_X_data</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">preprocessed_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">No y data passed to preprocess_y_data, preprocessing y data using default settings.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Perform y data preprocessing</span>
            <span class="n">preprocessed_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess_y_data</span><span class="p">()</span>

        <span class="c1"># Join X and y data</span>
        <span class="n">merged_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_X_to_y</span><span class="p">(</span><span class="n">preprocessed_X</span><span class="p">,</span> <span class="n">preprocessed_y</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Missing data before filling:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_missing_data</span><span class="p">(</span><span class="n">merged_data</span><span class="p">)</span>

        <span class="c1"># Fill data with averages</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Filling each site with the average for each species (creating decimal values in the data).</span><span class="se">\n</span><span class="s2">This will leave some NA values where a species has not been found at a particular site</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">avg_fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_na_with_avg</span><span class="p">(</span><span class="n">merged_data</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Missing data after filling with averages:&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_missing_data</span><span class="p">(</span><span class="n">avg_fill</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Fill data with XGBoost</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Spatially filling across sites using an XGBoost regressor trained on the coordinates of the y observations (also creates decimal values).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">xgb_fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_na_with_xgboost</span><span class="p">(</span><span class="n">avg_fill</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Missing data after filling with XGBoost:&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_missing_data</span><span class="p">(</span><span class="n">xgb_fill</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">s_print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Drop any remaining missing values (Count: </span><span class="si">{</span><span class="n">xgb_fill</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span> <span class="c1"># there shouldn&#39;t be any, but just incase</span>
        <span class="n">xgb_fill</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Split data into X and y</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_split</span><span class="p">(</span><span class="n">xgb_fill</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;site&#39;</span><span class="p">)</span>

        <span class="c1"># Multi_label_split</span>
        <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_label_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Multi-label SMOTE to add synthetic presence samples to the data (helps for species with few examples of presence).</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance_dataset_MLSMOTE</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">synth_count</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;Found array with 0 sample(s)&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Found array with 0 sample(s) while a minimum of 1 is required.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>  <span class="c1"># re-raise the exception if it&#39;s not the one we&#39;re looking for</span>

        <span class="c1"># Export data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">export_data_to_pickle</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span></div></div>



        




        
    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Will Armstrong.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>